import numpy as np
from scipy.optimize import least_squares, differential_evolution


# 54,03_0054.JPG,2018-10-23T08:38:51,32.33225475,119.8544629,466.28,        -0.011459,0.641713,-41.081074,-54.104405
# 55,03_0055.JPG,2018-10-23T08:38:59,32.33274749,119.8536493,466.03,         2.360586,-0.784952,-37.282364,-49.136861
# 点1的UTM坐标: (768690.3917918189, 3580846.0392339705)
# 点2的UTM坐标: (768612.3234587857, 3580898.6450968254)
def rotation_matrix(theta):
    """返回二维旋转矩阵"""
    return np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])


a = 3976 / 35.9
b = 2652 / 24
f = 35

K = np.array([[f * a, 0, 1988], [0, f * b, 1326], [0, 0, 1]])


def getp_c(p_uv):

    Z = 466.14
    K_inv = np.linalg.inv(K)
    p2 = p_uv.copy()
    p2.append(1)
    p2 = Z * np.array(p2)
    p_c = K_inv @ np.array(p2)
    p_c[2] = 1
    return p_c


# 假设已知的变换矩阵和点集
# T_wb1_list 和 T_wb2_list 是已知的 3x3 变换矩阵列表
# P1_list 和 P2_list 是对应的二维点列表，以齐次坐标表示 (x, y, 1)


T_wb1 = np.zeros((3, 3))
T_wb1[0:2, 0:2] = rotation_matrix(np.deg2rad(33.97))
T_wb1[0, 2] = 768690.3917918189 
T_wb1[1, 2] = 3580846.0392339705 
T_wb1[2, 2] = 1

T_wb2 = np.zeros((3, 3))
T_wb2[0:2, 0:2] = rotation_matrix(np.deg2rad(33.97))
T_wb2[0, 2] = 768612.3234587857 
T_wb2[1, 2] = 3580898.6450968254  
T_wb2[2, 2] = 1


P1_list = [
    [3273.5869140625, 199.10214233398438],
    [1950.925537109375, 780.2378540039062],
    [1438.895263671875, 1406.853759765625],
    [3627.298583984375, 201.1234893798828],
    [3279.598876953125, 272.881103515625],
    [1926.8770751953125, 675.1280517578125],
    [3262.564697265625, 286.01983642578125],
    [2817.66943359375, 127.34452056884766],
    [3276.593017578125, 277.9344787597656],
    [3282.60498046875, 211.23019409179688],
    [3284.609130859375, 259.7424011230469],
    [2632.296630859375, 163.72866821289062],
    [1089.191650390625, 1360.3629150390625],
    [374.7540588378906, 610.4451293945312],
]
P2_list = [
    [3567.177734375, 767.09912109375],
    [2263.5546875, 1474.5687255859375],
    [1805.6331787109375, 2146.664794921875],
    [3934.91748046875, 739.81103515625],
    [3578.19970703125, 842.8994140625],
    [2228.48388671875, 1367.4376220703125],
    [3561.16552734375, 857.048828125],
    [3089.2158203125, 732.736328125],
    [3575.19384765625, 848.9634399414062],
    [3577.19775390625, 779.2271728515625],
    [3583.2099609375, 829.7606811523438],
    [2902.8408203125, 786.3018798828125],
    [1453.925537109375, 2126.451416015625],
    [675.35888671875, 1429.0885009765625],
]
print("getp_c(P1_list[0]):", getp_c(P1_list[0]))
print("t_wb1:", T_wb1)
print("t_wb1 @ getp_c(P1_list[0]):", T_wb1 @ getp_c(P1_list[0]))


def transform(tx, ty, theta):
    """构建 T_bc 矩阵"""
    return np.array(
        [
            [np.cos(theta), -np.sin(theta), tx],
            [np.sin(theta), np.cos(theta), ty],
            [0, 0, 1],
        ]
    )


def residuals(params, P1_list, P2_list):
    tx, ty, theta = params
    T_bc = transform(tx, ty, theta)
    res = 0
    for P1, P2 in zip(P1_list, P2_list):
        # 计算 T_wb1 * T_bc * P1 和 T_wb2 * T_bc * P2
        lhs = T_wb1 @ T_bc @ getp_c(P1)
        rhs = T_wb2 @ T_bc @ getp_c(P2)

        # 计算 x 和 y 的差异
        # res.extend(lhs[:2] - rhs[:2])
        res += np.sum((lhs[:2] - rhs[:2]) ** 2)
    return res


# 初始猜测参数 [tx, ty,theta]
initial_guess = [0, 500, 0.0]

# 执行优化
result = least_squares(
    residuals,
    initial_guess,
    args=(P1_list, P2_list),
    verbose=2,  # 设置 verbose 参数以显示详细的优化过程
)
# bounds = [(0, 1000), (0, 1000), (-np.pi, np.pi)]

# result = differential_evolution(residuals, bounds,disp=True,args=(P1_list, P2_list))
tx_opt, ty_opt, theta_opt = result.x

print("优化得到的 T_bc 参数：")
print(f"旋转角度 (theta): {np.degrees(theta_opt):.4f} 度")
print(f"平移 tx: {tx_opt:.4f}")
print(f"平移 ty: {ty_opt:.4f}")

# 构建最终的 T_bc 矩阵
T_bc_opt = transform(tx_opt, ty_opt, theta_opt)
print("优化得到的 T_bc 矩阵：")
print(
    f"[[{T_bc_opt[0, 0]:.8f}, {T_bc_opt[0, 1]:.8f}, {T_bc_opt[0, 2]:.8f}],\n[{T_bc_opt[1, 0]:.8f}, {T_bc_opt[1, 1]:.8f}, {T_bc_opt[1, 2]:.8f}],\n[{T_bc_opt[2, 0]:.8f}, {T_bc_opt[2, 1]:.8f}, {T_bc_opt[2, 2]:.8f}]]"
)


# [[  0.52406656,0.85167731,4.86199931],
#  [ -0.85167731,0.52406656,-35.70721175],
#  [  0.          ,0.          ,1.        ]]
# =====================================验证=====================================
# 158,03_0158.JPG,2018-10-23T08:48:32,32.32075549,119.8679503,466.14,-1.604282,-0.635983,121.604562,127.47738
# 点1的UTM坐标: (769994.5817293458, 3579604.626693804)
# 159,03_0159.JPG,2018-10-23T08:48:36,32.3202341,119.8687524,465.99,0.991217,-0.263561,121.547267,127.718022
# 点2的UTM坐标: (770071.6695477746, 3579548.8239403595)

T_bc = T_bc_opt
# T_bc=np.array([[0.52835216, 0.84902532, -100.32498093],
# [-0.84902532, 0.52835216, 997.10104682],
# [0.00000000, 0.00000000, 1.00000000]])


def get_pose(p_uv):

    Z = 466.09
    K_inv = np.linalg.inv(K)
    p2 = p_uv.copy()
    p2.append(1)
    p2 = Z * np.array(p2)
    p_c = K_inv @ np.array(p2)
    print(f"p_c:{p_c}")
    p_c[2] = 1
    T_wb = np.zeros((3, 3))
    T_wb[0:2, 0:2] = rotation_matrix(np.deg2rad(34 + 180))
    T_wb[0, 2] = 769994.5817293458
    T_wb[1, 2] = 3579604.626693804
    T_wb[2, 2] = 1
    print(f"p_b:{T_bc @ p_c}")
    P_w = T_wb @ T_bc @ p_c
    return P_w


def get_p_uv(pw):

    Z = 466.14
    T_wb = np.zeros((3, 3))
    T_wb[0:2, 0:2] = rotation_matrix(np.deg2rad(34 + 180))
    T_wb[0, 2] = 770071.6695477746
    T_wb[1, 2] = 3579548.8239403595
    T_wb[2, 2] = 1

    # 计算 T_bw
    T_bw = np.linalg.inv(T_wb)

    T_cb = np.linalg.inv(T_bc)
    pw = np.array([pw[0], pw[1], 1])
    print(f"p_b:{T_bw @ pw}")
    p_c = T_cb @ T_bw @ pw
    p_c[2] = Z
    print(f"p_c:{p_c}")
    p_uv = 1 / Z * K @ p_c
    return p_uv[:2]


p_w = get_pose([2674.381103515625, 935.8811645507812])
print(f"像素坐标为[2674.381103515625,935.8811645507812]的世界坐标为{p_w}")
p_uv = get_p_uv(p_w)
# [2671.375244140625, 1767.6632080078125]
print(f"世界坐标为{p_w}的像素坐标为{p_uv}")
